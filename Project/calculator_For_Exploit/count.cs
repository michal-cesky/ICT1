using Microsoft.SqlServer.Server;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Calculator_for_exploit
{
    internal class count
    {
        count_Sum count_Sum = new count_Sum();
        count_Factorial count_Factorial = new count_Factorial();

        private static int result_Plus = 0;
        private static int result_Divided = 0;
        private static double result_Double = 0;
        private static string first_Number, second_Number, operand;

        public static void counting(string[] arry)
        {
            if (arry.Length < 3)
            {
                Console.WriteLine("This application is used to test applications for vulnerabilities.\n" +
                    " Application itself contains a total of 4 vulnerabilities (Integer overflow, Stack overflow, String format, Heap overflow).\n" +
                    " The application can be used either for direct exploitation or for exploits.\n" +
                    " You can enter two numbers into the application and the operand (+, -, *, /, !, SUM)\n" +
                    " For exploitations please add both numbers and operand (Firstnumber Operand Secondnumber) even if the second one is not needed in some cases.\n" +
                    " Please press any button to launch the app.");
                Console.ReadLine();
                Console.Write("Enter the first number: ");
                first_Number = Console.ReadLine();
                Console.Write("Enter the operand (+, -, *, /, !, SUM): ");
                operand = Console.ReadLine();
                Console.Write("Enter the second number: ");
                second_Number = Console.ReadLine();
            }
            else
            {
                first_Number = arry[0];
                operand = arry[1];
                second_Number = arry[2];
            }

            if (!double.TryParse(first_Number, out _))
            {
                Console.WriteLine("This operation could invoke a string format error. However, in this case this error is addressed here. Please try to find the error elsewhere.");
                return;
            }


            if (!double.TryParse(second_Number, out _))
            {
                Console.WriteLine("This operation could invoke a string format error. However, in this case this error is addressed here. Please try to find the error elsewhere.");
                return;
            }

            if (first_Number == "") first_Number = "0";
            if (second_Number == "") second_Number = "0";

            switch (operand)
            {
                case "+":
                    checked
                    {
                        try
                        {
                            result_Plus = int.Parse(first_Number) + int.Parse(second_Number);
                        }
                        catch (OverflowException)
                        {
                            Console.WriteLine("Congratulations you found the Intiger overflow error. Restart the application to find other errors.");
                        }
                        catch (FormatException)
                        {
                            Console.WriteLine("Well done you found the String format error. Restart the application to find other errors.");
                        }
                    }
                    break;
                case "-":
                    result_Double = double.Parse(first_Number) - double.Parse(second_Number);
                    break;
                case "*":
                    result_Double = double.Parse(first_Number) * double.Parse(second_Number);
                    break;
                case "/":
                    if (int.Parse(second_Number) == 0)
                    {
                        Console.WriteLine("This error is addressed here. Try to find the error elsewhere.");
                        return;
                    }
                    result_Double = double.Parse(first_Number) / double.Parse(second_Number);

                    break;
                case "!":
                       result_Double = count_Factorial.factorialFunction(Double.Parse(first_Number));
                    break;
                case "SUM":
                    result_Double = count_Sum.Count_Sum(Double.Parse(first_Number));
                    break;
                default:
                    Console.WriteLine("This operation could invoke a String format error.However, in this case it is not useful.Please try to find the error elsewhere.\n" +
                        "Please use valid operand.");
                    return;
            }

            if (result_Double == 0)
            {

                if (result_Plus != 0)
                {
                    Console.WriteLine("Result: " + result_Plus);
                    return;
                }
                if (result_Divided != 0)
                {
                    Console.WriteLine("Result: " + result_Divided);
                    return;
                }
            }
            else
            {
                Console.WriteLine("Result: " + result_Double);             
                return;
            }
        }
    }
}
